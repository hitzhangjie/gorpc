@startuml

package "helloworld" {

    interface Greeter {
        +Hello(ctx, *Request) (*Response, error)
    }

    class greeter {
        +Hello(ctx, *Request) (*Response, error)
    }
    greeter -up-|> Greeter

    class Greeter_ServiceDesc {
        Name string
        Methods map[string]HandleFunc
    }
}

package "server" {

    class Server {
        +modules []*ServerModule
        +interceptors []Interceptor
        +Start()
        +Stop()
        +Register(s *ServerModule) error
        +AtExit(fn func())
    }

    interface ServerModule {
        +Start()
        +Stop()
    }
    Server "1" *-down- "N" ServerModule

    class PacketServer {
        svr *Server
    }
    PacketServer -up-|> ServerModule

    class StreamServer {
        svr *Server
    }
    StreamServer -up-|> ServerModule

    class HttpServer {
        svr *Server
    }
    HttpServer -up-|> ServerModule

    Server -up-> greeter
    Server -up-> Greeter_ServiceDesc

    interface Router {
        Route(rpc string) (Method, error)
    }
    Server -down-> Router

    interface Interceptor {
    	Intercept(ctx context.Context) error
    }
	Server "1" -left-> "N" Interceptor
}

package "codec" {

    interface Session {
        TraceContext() (interface{}, error)
        ParseRequestBody(req interface{}) error
        Request() interface{}
        Response() interface{}
        Logger() logger
    }

    interface Codec {
        Encode(v interface{}) ([]byte, error)
        Decode([]byte) (interface{}, error)
    }


    class MessageReader {
        codec Codec
        builder SessionBuilder
        Read(net.Conn) (interface{}, error)
    }

    interface SessionBuilder {
    	Build(req interface{}) (Session, error)
    }


    MessageReader -down-> Codec
    MessageReader -down-> SessionBuilder
    SessionBuilder -up-> Session

    StreamServer -down-> MessageReader
    PacketServer -down-> MessageReader
    HttpServer -down-> MessageReader
}

package "internal.codec" {
    GoRPC -up-|> Codec
    GRPC -up-|> Codec
    HTTP -up-|> Codec
}

package "internal.builder" {
    GoRPCBuilder -up-|> SessionBuilder
    GRPCBuilder -up-|> SessionBuilder
    HTTPBuilder -up-|> SessionBuilder
}


package "registry" {
    interface Registry {
        +Register(*Service, opts ... RegisterOption) error
        +DeRegister(*Service) error
        +GetService(string) ([]*Service, error)
        +ListServices() ([]*Service, error)
        +Watcher() (Watcher, error)
    }
    Registry "1" *-right- "1" Watcher
    Registry "1" -up-> "N" Service
    Server -left-> Registry

    interface Watcher {
        +Next() (*Result, error)
        +Stop()
    }
    Watcher -up-> Result

    class Result {
        +Action ActionType
        +Service *Service
    }
    enum Action {
        CREATE
        UPDATE
        DELETE
    }
    Result -right-> Action

    class Service {
    	Name string
    	Version string
    	Nodes []Node
    }
    Service "1" -right-> "N" Node

    class Node {
    	IP string
    	Port int
    	Weight int
    }
}

package "selector" {
	interface Selector {
		Select(service string, opts ...SelectOption) (Next, error)
	    Mark(service string, node *registry.Node, err error)
     	Reset(service string)
    	Close() error
    }
    Selector -up-> Registry
}

package "internal.selector" {
    IPSelector --|> Selector
    EtcdSelector -left-|> Selector
}

package "client" {

    interface Client {
        Invoke(ctx, req) (rsp, error)
    }

    interface Transport {
        Send(ctx, req) (rsp, error)
    }
    class TcpTransport {
        pool *TcpConnectionPool
        eps []*Endpoint
        rd *MessageReader
    }
    TcpTransport -left-|> Transport
    TcpTransport "1" -right-> "TcpConnectionPool"

    class UdpTransport {
        ep *Endpoint
        rd *MessageReader
    }
    UdpTransport -up-|> Transport
    UdpTransport -right-|> Endpoint

    interface ConnectionPool {
        +GetConn() (net.Conn, error)
        +FreeConn(net.Conn)
    }
    TcpConnectionPool --|> ConnectionPool
    TcpConnectionPool "1" --> "N" Endpoint

    class Endpoint {
        -conn net.Conn
        +Read([]byte) (n, error)
        +Write([]byte) (n, error)
    }

    class client {
        name string
        codec Codec
        selector Selector
        trans Transport
        +Invoke(ctx, req) (rsp, error)
    }

    client -right-|> Client
    client -right-> MessageReader
    client -down-> Transport
    client -up-> Selector
}

package "broker" {
    interface Broker {
        ServerModule
        Subsribe(ctx, topic, gp) (<-chan interface{}, error)
        Publish(ctx, topic, req) error
    }
    Broker --|> ServerModule
}

package "internal.broker" {
    NATS --|> Broker
    Kafka --|> Broker
}

@enduml